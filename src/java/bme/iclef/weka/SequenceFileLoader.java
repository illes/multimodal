package bme.iclef.weka;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.regex.Pattern;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.SequenceFile;
import org.apache.hadoop.io.Text;
import org.apache.mahout.math.Vector;
import org.apache.mahout.math.VectorWritable;

import weka.core.Attribute;
import weka.core.FastVector;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.converters.AbstractFileLoader;
import weka.core.converters.ArffSaver;

public class SequenceFileLoader extends AbstractFileLoader {

    private static final long serialVersionUID = 5939535999205466183L;

    /** the file extension. */
    public static String FILE_EXTENSION = ".seq";

    /** The placeholder for missing values. */
    protected double m_MissingValue = Double.NaN;

    /**
     * default constructor.
     */
    public SequenceFileLoader() {
	// No instances retrieved yet
	setRetrieval(NONE);
    }

    @Override
    public Instance getNextInstance(Instances structure) throws IOException {
	throw new UnsupportedOperationException();
    }

    @Override
    public String getFileDescription() {
	return "Apache Mahout sequence file";
    }

    @Override
    public String getFileExtension() {
	return FILE_EXTENSION;
    }

    @Override
    public String[] getFileExtensions() {
	return new String[] { getFileExtension() };
    }

    /**
     * Resets the Loader object and sets the source of the data set to be the
     * supplied Stream object.
     * 
     * @param input
     *            the input stream
     * @exception IOException
     *                if an error occurs
     */
    @Override
    public void setSource(InputStream input) throws IOException {
	throw new UnsupportedOperationException("not implemented");
    }

    /**
     * Resets the {@link SequenceFileLoader} object and sets the source of the
     * data set to be the supplied {@link File} object.
     * 
     * @param file
     *            the source file.
     * @exception IOException
     *                if an error occurs
     */
    @Override
    public void setSource(File file) throws IOException {
	m_sourceFile = file;
    }

    /**
     * Determines and returns (if possible) the structure (internally the
     * header) of the data set as an empty set of instances.
     * 
     * @return the structure of the data set as an empty set of Instances
     * @exception IOException
     *                if an error occurs
     */
    @Override
    public Instances getStructure() throws IOException {
	if (m_sourceFile == null) {
	    throw new IllegalStateException("No source has been specified");
	}
	
	return m_structure;
    }
    
    /**
     * Set the dataset header to be used instead of the one generated by {@link #instancesForVector(String, int)}.
     * @param instances
     */
    public void setDataSet(Instances instances) {
	m_structure = new Instances(instances, 0);
    }
    
    
    @Override
    public Instances getDataSet() throws IOException {
	Instance inst = null;
	
	if (m_structure == null || m_structure.numInstances() == 0) {
	    SequenceFile.Reader reader = null;
	    try {
		Configuration config = new Configuration();
		Path path = new Path(m_sourceFile.getPath());
		reader = new SequenceFile.Reader(FileSystem.get(config), path,
			config);

		final Text key = (Text) reader.getKeyClass().newInstance();
		final VectorWritable value = (VectorWritable) reader
			.getValueClass().newInstance();
		
		while (reader.next(key, value)) {
		    final Vector vector = value.get();
		    if (m_structure == null) {
			final String relationName;
			if (m_sourceFile != null)
			    relationName = m_sourceFile.getName().replace(
				    "(?i)" + Pattern.quote(getFileExtension())
					    + "$", "");
			else
			    relationName = "stream";
			
			m_structure = instancesForVector(relationName, vector.size());			
		    }
		    
		    if (inst == null)
			inst = new Instance(m_structure.numAttributes());
		    
		    // convert & add
		    vectorToInstance(vector, inst);
		    if(!m_structure.checkInstance(inst))
			throw new IllegalStateException("incompatible intance from vector: '" + key + "' => " + inst.toString());
		    m_structure.add(inst); // copy
		}
		if (m_structure == null || m_structure.numInstances() == 0) {
		    throw new IllegalStateException("Empty sequence file?");
		}
	    } catch (InstantiationException e) {
		throw new RuntimeException(e);
	    } catch (IllegalAccessException e) {
		throw new RuntimeException(e);
	    } finally {
		if (reader != null)
		    reader.close();
	    }
	}
	return m_structure;
    }

    /**
     * Creates an empty dataset with a first string <code>"id"</code> attribute, <code>size</code> number of numeric attributes, and a last <code>"label"</code> string attribute.
     * @param relationName
     * @param size
     * @return
     */
    public static Instances instancesForVector(String relationName, int size) {
	final FastVector attribNames = new FastVector(size + 2);

	attribNames.addElement(new Attribute("id",
		(FastVector) null));

	// data (numeric) attributes
	for (int i = 0; i < size; i++)
	    attribNames.addElement(new Attribute("attr_" + i));

	attribNames.addElement(new Attribute("label",
		(FastVector) null));

	return new Instances(relationName, attribNames, 0);
    }

    /**
     * Converts a Mahout {@link Vector} to a Weka {@link Instance}. Adds an
     * empty first and last column.
     * 
     * @param v
     * @return
     */
    public static Instance vectorToInstance(Vector v) {
	final Instance inst = new Instance(v.size() + 2);
	vectorToInstance(v, inst);
	return inst;
    }

    
    public static void vectorToInstance(Vector v, Instance inst) {
	if (inst.numAttributes() != v.size() + 2)
	    throw new IllegalArgumentException("wrong number of attributes");
	
	inst.setValue(0, Instance.missingValue()); // 0: id column
	for (int i = 0; i < v.size(); i++) {
	    inst.setValue(i + 1, v.get(i)); // 1..(n-1): value columns
	}
	inst.setValue(inst.numAttributes() - 1, Instance.missingValue()); // n: label column
    }
    
    @Override
    public String getRevision() {
	return "0.1";
    }
    
    public static void main(String[] args) throws IOException {
	String dataFile = args[0];
	System.err.println("INFO: Loading dataset from '" + dataFile + "' ...");

	SequenceFileLoader loader = new SequenceFileLoader();
	loader.setSource(new File(dataFile));

	Instances data = loader.getDataSet();

	ArffSaver saver = new ArffSaver();
	saver.setDestination(System.out);
	saver.setInstances(data);
	saver.writeBatch();
    }

}
